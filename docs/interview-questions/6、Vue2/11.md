# 11、响应式原理

``` js
// src/lifecycle.js

import Watcher from './observer/watcher'
import {patch} from './vdom/patch'

export function lifecycleMixin(Vue) {
  Vue.prototype._update = function(vnode) {
    // 既有初始化又有更新
    const vm = this
    vm.$el = patch(vm.$el, vnode)
  }
}

export function mountComponent(vm, el) {
  // 更新函数，数据变化后，再次调用此函数
  let updateComponent = () => {
    // 调用render函数，生成虚拟dom
    vm._update(vm._render()) // 后续更新可以调用updateComponent

    // 用虚拟dom生成真是dom
  }

  new Watcher(vm, updateComponent, ()=>{
    console.log('更新视图了')
  }, true) // 是一个渲染watcher
}
```

``` js
// src/observer/watcher.js

import { popTarget, pushTarget } from "./dep"

let id = 0

export default class Watcher {
  constructor(vm, exprOrFn, callback, options) {
    this.vm = vm
    this.exprOrFn = exprOrFn
    this.callback = callback
    this.options = options
    this.id = id++

    this.getter = exprOrFn

    this.deps = []
    this.depsId = new Set()

    this.get() // 默认初始化取值
  }

  get(){
    pushTarget(this)
    this.getter()
    popTarget()
  }

  update(){
    this.get()
  }

  addDep(dep) {
    let id = dep.id
    if(!this.depsId.has(id)) {
      this.depsId.add(id)
      this.deps.push(dep)
      dep.addSub(this)
    }
  }
}
```

``` js
// src/observer/dep.js

let id = 0

export default class Dep {
  constructor(){
    this.id = id++
    this.subs = [] // 用来存放watcher
  }

  depend(){
    if(Dep.target) {
      Dep.target.addDep(this)
    }
  }

  addSub(watcher){
    this.subs.push(watcher)
  }

  notify(){
    this.subs.forEach(watcher=>watcher.update())
  }
}

Dep.target = null

export function pushTarget(watcher) {
  Dep.target = watcher
}

export function popTarget(){
  Dep.target = null
}
```

``` js
// src/observer/index.js
import Dep from './dep'
...
function defineProperty(data,key,value) {
  observe(value)
  let dep = new Dep()
  Object.defineProperty(data,key,{
    get(){
      if(Dep.target) {
        dep.depend()
      }
      return value
    },
    set(newValue) {
      if(newValue !== value) {
        observe(newValue)
        value = newValue
        dep.notify()
      }
    }
  })
}
```