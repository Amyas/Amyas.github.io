# 2、响应式处理

## 使用方法

``` html
<!-- index.html -->
<div id="app">{{name}}</div>
<script src="dist/vue.js"></script>
<script>
  let vm = new Vue({
    data: {
      name: 'amyas'
    }
  })
</script>
```

## 实现Vue构造函数

``` js
// src/index.js
function Vue(options){
  // options为用户传入的选项
  this._init(options) // 初始化操作
}

export default Vue
```

这些样有一个问题，如果后续Vue构造函数上存在多个方法，都写在一个文件里，不好维护，所以我们做一下拆分

## 实现init方法

``` js
// src/init.js
export function initMixin(Vue) { //表示在vue的基础上做一次混合操作
  Vue.prototype._init = function(options) {
    console.log(options)
  } 
}
```

## 修改vue构造函数

``` js
// src/index.js
import {initMixin} from './init'

function Vue(options){
  // options为用户传入的选项
  this._init(options) // 初始化操作
}
initMixin(Vue)

export default Vue
```

此时我们就实现了混合操作。

## 实现_init方法

在vue中，我们可以通过`vm.$options`拿到传入的参数，接下来实现：

``` js
// src/init.js
export function initMixin(Vue) { //表示在vue的基础上做一次混合操作
  Vue.prototype._init = function(options) {
    const vm = this
    vm.$options = options // 后续会对options进行扩展
  } 
}
```

接下来对数据进行响应式处理。

## 实现数据初始化

``` js
// src/init.js
import {initState} from './state'
export function initMixin(Vue) { //表示在vue的基础上做一次混合操作
  Vue.prototype._init = function(options) {
    const vm = this
    vm.$options = options // 后续会对options进行扩展

    // 对数据进行初始化 watch computed props data
    initState(vm)
  } 
}
```

### 初始化data

``` js
// src/state.js
export function initState(vm){
  const opts = vm.$options
  if(opts.data) {
    initData(vm)
  }
}

function initData(vm) {
  let data = vm.$options.data

  // vue2中会将data中的所有数据劫持，Object.defineProperty
}
```

由于vue传入的data可能是funciton也可能是object，所以我们做一层判断

``` js
// src/utils.js
export function isFunction(value){
  return typeof value === 'function'
}
```

``` js
// src/state.js
import {isFunction} from './utils'
export function initState(vm){
  const opts = vm.$options
  if(opts.data) {
    initData(vm)
  }
}

function initData(vm) {
  let data = vm.$options.data
  
  // vue2中会将data中的所有数据劫持，Object.defineProperty
  data = isFunction(data) ? data.call(vm) : data
}
```

再次基础上，我们就要来监听观测我们的data

``` js
// src/state.js
import {observe} from './observer/index'

...
function initData(vm) {
  let data = vm.$options.data

  // 将数据挂在到vm._data中，方便后续观测
  data = vm._data = isFunction(data) ? data.call(vm) : data

  observe(data)
}
```

在实现observe，我们需要明确，只有是object对象我们才进行监听观测，所以我们先实现isObject方法

``` js
// src/utils.js
export function isObject(value) {
  return typeof value === 'object' && typeof value !== null
}
```

接来下传入observe的数据如果不是data则return，反之创建一个观测者

``` js
// src/observer/index.js
import {isObject} from '../utils'
export function observe(data) {
  // 如果是对象才进行观测

  if(!isObject(data)) {
    return
  }

  return new Observer(data)
}
```

实现一个观测者：

``` js
// src/observer/index.js
class Observer {
  constructor(data) { // 对对象中的所有属性进行劫持
    this.walk(data)
  }
  walk(data) {
    Object.keys(data).forEach(key=>{
      defineReactive(data, key, data[key])
    })
  }
}

// vue2会对对象进行遍历，全量、性能差
function defineReactive(data, key, value) {
  Object.defineProperty(data,key,{
    get(){
      return value
    },
    set(newValue) {
      value = newValue
    }
  })
}
```

此时如果存在对象嵌套，我们发现没有被observe劫持，接下来实现下

``` js
// src/observer/index.js
function defineReactive(data, key, value) {
  observe(value)
  Object.defineProperty(data,key,{
    get(){
      return value
    },
    set(newValue) {
      observe(newValue)
      value = newValue
    }
  })
}
```

## 测试

在html中console.log(vm)查看_data是否所有属性都添加上了get set，添加嵌套object查看是否都添加上了get set

``` js
<!-- index.html -->
let vm = new Vue({
  data(){
    return {
      name: 'amyas',
      a:{
        b:{
          a:1
        }
      }
    }
  }
})
console.log(vm)
```