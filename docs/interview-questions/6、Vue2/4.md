# 4、数组的递归监控

通过`defineProperty`对数组进行劫持，性能消耗比较大，所以在vue2中不通过此方法进行数组代理，而是通过如下方式改写7个数组方法：

``` js
// src/observer/index.js
...
import {arrayMethods} from './array'
class Observer {
  constructor(data) {
    // data.__ob__ = this // 会无限添加ob属性，所以要设置不可枚举
    Object.defineProperty(data,'__ob__',{
      value: this,
      enumerable: false
    })
    if(Array.isArray(data)) {
      // 对数组原来的方法进行改写
      data.__proto__ = arrayMethods
      // 如果数组中的数据是对象类型，需要监控对象的变化
      this.observeArray(data)
    } else {
      this.walk(data)
    }
  }
  observeArray(data) {
    data.forEach(item=>observe(item))
  }
}
export function observe(data) {
  if(!isObject(data)) {
    return 
  }
  if(data.__ob__) {
    return; // 如果已经观测过了，就不用继续观测
  }

  return new Observer(data)
}
```

``` js
// src/observer/array.js
let oldArrayPrototype = Array.prototype
export let arrayMethods = Object.create(Array.prototype) // 拷贝array原方法
// arrayMethods.__proto__ = Array.prototype

let methods = [
  'push',
  'shift',
  'unshift',
  'pop',
  'reverse',
  'sort',
  'splice'
]

methods.forEach(method=>{
  arrayMethods[method] = function(...args) {
    oldArrayPrototype[method].call(this, ...args)

    let inserted;
    let ob = this.__ob__

    switch(method) {
      case 'push':
      case 'unshift':
        inserted = args
        break;
      case 'splice':
        inserted = args.slice(2)
      default:
        break;
    }

    // 如果有新增的内容，继续劫持，观测数组中的每一项
    if(inserted) {
      ob.observeArray(inserted )
    }
  }
})
```