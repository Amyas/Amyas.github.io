# 12、异步更新原理

``` js
// src/lifecycle.js

import { nextTick } from './utils'

export function lifecycleMixin(Vue) {
  ...
  Vue.prototype.$nextTick = nextTick
}
...
```

``` js
// src/utils.js
...

const callbacks = []
function fluashCallbacks(){
  callbacks.forEach(cb=>cb())
  waiting = false
}

function timer(fluashCallbacks){
  let timerFn = ()=>{
  }

  if(Promise) {
    timerFn = ()=>Promise.resolve().then(fluashCallbacks)
  } else if (MutationObserver){
    let textNode = document.createTextNode(1)
    let observe = new MutationObserver(fluashCallbacks)
    observe.observe(textNode,{
      characterData: true
    })
    timerFn = () => {
      textNode.textContent = 3
    }
  } else if (setImmediate) {
    timerFn = ()=>{
      setImmediate(fluashCallbacks)
    }
  } else {
    timerFn = ()=>{
      setTimeout(fluashCallbacks);
    }
  }
  timerFn()
}

let waiting = false
export function nextTick(callback){
  callbacks.push(callback)

  if(!waiting) {
    timer(fluashCallbacks, 0);
    waiting = true
  }
}
```

``` js
// src/observer/scheduler.js

import { nextTick } from "../utils"

let queue = []
let has = {}

let pending = false

function fluashSchedulerQueue(){
  for(let i = 0;i<queue.length;i++) {
    queue[i].run()
  }
  queue = []
  has = {}
  pending = false
}

export function queueWatcher(watcher) {
  const id = watcher.id
  if(has[id] === null || has[id] === undefined) {
    queue.push(watcher)
    has[id] = true

    if(!pending) {
      nextTick(fluashSchedulerQueue, 0);
      pending = true
    }
  }

}
```

``` js
// src/observer/watcher.js
import { queueWatcher } from "./scheduler"

export default class Watcher {
  ...
  update(){
    queueWatcher(this) // 多次调用update，先缓存watcher，一会一起更新
  }

  run(){
    this.get()
  }
  ...
}
```