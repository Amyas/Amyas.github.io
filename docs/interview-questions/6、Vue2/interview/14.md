# 14.nextTick 实现

```js
// utils.js
let callbacks = [];
let waiting = false;
function fluashCallbacks() {
  callbacks.forEach((cb) => cb());
  callbacks = [];
  waiting = false;
}

function timer(fluashCallbacks) {
  let timerFn = () => {};
  if (Promise) {
    timerFn = () => Promise.resolve().then(fluashCallbacks);
  } else if (MutationObserver) {
    let textNode = document.createTextNode(1);
    let observe = new MutationObserver(fluashCallbacks);
    observe.observe(textNode, {
      characterData: true,
    });
    timerFn = () => {
      textNode.textContent = 3;
    };
  } else if (setImmediate) {
    timerFn = () => {
      setImmediate(fluashCallbacks);
    };
  } else {
    timerFn = () => setTimeout(fluashCallbacks);
  }
  timerFn();
}

function nextTick(callback) {
  callbacks.push(callback);
  if (!waiting) {
    timer(fluashCallbacks);
    waiting = true;
  }
}
```

```js
// watcher.js
let queue = [];
let has = {};
let pending = false;

function fluashSchedulerQueue() {
  for (let i = 0; i < queue.length; i++) {
    queue[i].run();
  }
  queue = [];
  has = {};
  pending = false;
}

function queueWatcher(watcher) {
  const id = watcher.id;

  if (has[id] === null || has[id] === undefined) {
    queue.push(watcher);
    has[id] = true;

    if (!pending) {
      nextTick(fluashSchedulerQueue);
      pending = true;
    }
  }
}

class Watcher {
  construcotr(vm, expOrFn) {
    ...
  }

  update(){
    queueWatcher(this)
  }

  run(){
    this.get()
  }
}
```
