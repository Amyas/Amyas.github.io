# 13.diff 乱序对比

```js
// vue.js
Vue.prototype._update = function (vnode) {
  const vm = this;

  const prevNode = vm._vnode;
  if (!prevNode) {
    vm.$el = patch(vm.$el, vnode);
  } else {
    vm.$el = patch(prevNode, vnode);
  }
  vm._vnode = vnode;
};
```

```js
// vdom.js
function patch(oldVnode, vnode) {
  if (oldVnode.nodeType === 1) {
    ...
  } else {
    ...
    return el
  }
}

function patchChildren(el, oldChildren, newChildren) {
  const makeIndexByKey = (children) => {
    return children.reduce((total, current, index) => {
      if (current.key) {
        total[current.key] = index;
      }
      return total;
    }, {});
  };

  const keysMap = makeIndexByKey(oldChildren);

  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (!oldStartVnode) {
      oldStartVnode = oldChildren[++oldStartIndex];
    } else if (!oldEndVnode) {
      oldEndVnode = oldChildren[--oldEndIndex];
    }

    if(isSameVnode(oldStartVnode, newStartVnode)) {
      ...
    } else {
      // 需要根据key和对应的索引将老的内容生成映射表
      let moveIndex = keysMap[newStartVnode.key] // 拿新的去老的中查找
      if(!moveIndex) {
        // 如果不能复用直接创建新的插入到老的节点开头处
        el.insertBefore(createElm(newStartVnode), oldStartVnode.el)
      } else {
        let moveNode = oldChildren[moveIndex]
        oldChildren[moveIndex] = null //准备将该节点移走，null站位
        el.insertBefore(moveNode.el, oldStartVnode.el)
        patch(moveNode, newStartVnode)
      }
      newStartVnode = newChildren[++newStartIndex]
    }
  }

  ...

  if (oldStartIndex <= oldEndIndex) {
    for (let i = oldStartIndex; i <= oldEndIndex; i++) {
      if(oldChildren[i] !== null) {
        el.removeChild(oldChildren[i].el);
      }
    }
  }
}
```
