# 1.02-02(参数_返回值_局部变量_数组反汇编)

## 返回值是如何传递的？

1、char类型的返回值

    放到al寄存器，站1个字节，8位

2、short 类型的返回值

    放到ax寄存器，站2个字节，16位

3、int 类型的返回值

    放到eax寄存器，站4个字节，32位


## 参数传递的本质

1、8位参数传递				
				
				
    void Function(char x,char y,char z)				
    {				
                    
                    
    }				
				
				
2、16位参数传递				
				
				
    void Function(short x,short y,short z)				
    {				
                    
                    
    }				
				
3、32位参数传递				
				
    void Function(int x,int y,int z)				
    {				
                    
                    
    }				

三个例子在传递参数时都是按照int类型传递

原因：

1、本机尺寸：
    
    如果本机是32位的，那么对32位的数据支持最好，如果是64位的，那么对64位的支持最好.								
									
2、编译器遵守了这个规则:									
									
	char类型或者short类型的参数不但没有节省空间，反而浪费了多余的操作.								
									
结论：
    
    整数类型的参数，一律使用int类型									
									
总结：								
								
    参数传递的本质：将上层函数的变量，或者表达式的值“复制一份”，传递给下层函数.								



## 局部变量的内存分配

### 实例：

```c++
void Function()			
{			
    char a = 1;		
    char b = 2;		
            
    short c = 3;		
    short d = 4;		
            
}	
```
			
			
			
```c++
void Function(int x,int y)			
{			
	char a = x;		
	char b = y;		
			
	x = 3;		
	y = 4;		
}			
```

### 总结：						
						
1、小于32位的局部变量，空间在分配时，按32位分配.						
						
2、使用时按实际的宽度使用.						
						
3、不要定义char/short类型的局部变量.						
						
4、参数与局部变量没有本质区别，都是局部变量，都在栈中分配.						
						
5、完全可以把参数当初局部变量使用						
						

## 赋值语句的本质

### 示例:		
		
```c++
int x = 1;		
		
int x = 1;		
int y = 2;		
int z = 3;		
		
int r = 1*2+3;		
int r = 1*(2+3);	
```	

### 赋值的本质：			
			
将某个值存储到变量中的过程就是赋值.			

## 数组的本质

### 示例：定义10个变量，观察反汇编					
					
```c++
void Function()					
{					
	int v_0 = 1;				
	int v_1 = 2;				
	int v_2 = 3;				
	int v_3 = 4;				
	int v_4 = 5;				
	int v_5 = 6;				
	int v_6 = 7;				
	int v_7 = 8;				
	int v_8 = 9;				
	int v_9 = 10;				
}				
void Function()					
{					
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};				
}				
```

### 总结：						
						
1、一组相同类型的变量，为了方便读写，采用另外一种表示形式.						
						
2、数组在声明的时候，必须用常量来指明长度，不能使用变量.						


## 数组的使用

### 示例：					

```c++					
void Function()					
{					
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};				
					
	int x = 1;				
	int y = 2;				
	int r ;				
					
	r = arr[1];				
	r = arr[x];//可以吗？				
	r = arr[x+y];//可以吗？				
	r = arr[x*2+y];//可以吗？				
	r = arr[arr[1]+arr[2]];可以吗				
	r = arr[Add(1,2)];可以吗？				
	int a5 = arr[100];//可以吗？				
}					
```

### 总结：							
							
1、数组在使用时，可以通过变量来定位数据.							
							
2、数组定位时，可以超过数组的长度，编译不会有错，但读取的数据是错的.							
							
