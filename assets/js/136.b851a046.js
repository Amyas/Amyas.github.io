(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{406:function(a,s,_){"use strict";_.r(s);var v=_(13),t=Object(v.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_7、http缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、http缓存"}},[a._v("#")]),a._v(" 7、HTTP缓存")]),a._v(" "),s("h2",{attrs:{id:"缓存相关header"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存相关header"}},[a._v("#")]),a._v(" 缓存相关header")]),a._v(" "),s("p",[a._v("我们先罗列一下和缓存相关的请求响应头。")]),a._v(" "),s("h3",{attrs:{id:"强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),s("ul",[s("li",[a._v("Expires")])]),a._v(" "),s("p",[s("strong",[a._v("响应头，代表该资源的过期时间")])]),a._v(" "),s("ul",[s("li",[a._v("Cache-Control")])]),a._v(" "),s("p",[s("strong",[a._v("请求/响应头，缓存控制字段，精确控制缓存策略")])]),a._v(" "),s("p",[a._v("服务器不会向服务器发送任何请求，直接从本地缓存中读取文件并返回Statu Code: 200 ok")]),a._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/Amyas/picgo-bed/master/amyas.github.io/72022-04-15-15-23-27.png",alt:"72022-04-15-15-23-27",width:"",height:""}}),a._v(" "),s("p",[s("strong",[a._v("200 from memory cache: 不访问服务器，一般已经加载过该资源且缓存在了内容当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。")])]),a._v(" "),s("p",[s("strong",[a._v("200 from disk cache：不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉，下次打开仍然会是from disk cache。")])]),a._v(" "),s("p",[s("strong",[a._v("优先访问memory cache，其次是disk cache，最后是请求网络资源。")])]),a._v(" "),s("p",[s("strong",[a._v("expires是http1.0的头字段，cache-control是http1.1的头字段。如果同时存在，cache-control会覆盖expires，建立两个都写")])]),a._v(" "),s("h3",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),s("ul",[s("li",[a._v("If-Modified-Since")])]),a._v(" "),s("p",[s("strong",[a._v("请求头，资源最近修改时间，由浏览器告诉服务器")])]),a._v(" "),s("ul",[s("li",[a._v("Last-Modified")])]),a._v(" "),s("p",[s("strong",[a._v("响应头，资源最近修改时间，由服务器告诉浏览器")])]),a._v(" "),s("ul",[s("li",[a._v("Etag")])]),a._v(" "),s("p",[s("strong",[a._v("响应头，资源标识，由服务器告诉浏览器")])]),a._v(" "),s("ul",[s("li",[a._v("If-None-Match")])]),a._v(" "),s("p",[s("strong",[a._v("请求头，缓存资源标识，由浏览器告诉服务器")])]),a._v(" "),s("p",[a._v("向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态吗并带上新的response header通知浏览器从缓存中读取资源")]),a._v(" "),s("p",[a._v("协商缓存头是成对出现")]),a._v(" "),s("p",[a._v("配对使用的字段：")]),a._v(" "),s("ul",[s("li",[a._v("If-Modified-Since和LastModified")]),a._v(" "),s("li",[a._v("Etag和If-None-Match")])]),a._v(" "),s("h2",{attrs:{id:"浏览器是如何判断是否使用缓存的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是如何判断是否使用缓存的"}},[a._v("#")]),a._v(" 浏览器是如何判断是否使用缓存的")]),a._v(" "),s("p",[a._v("第一次请求：")]),a._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/Amyas/picgo-bed/master/amyas.github.io/72022-04-15-15-19-49.png",alt:"72022-04-15-15-19-49",width:"",height:""}}),a._v(" "),s("p",[a._v("第二次请求相同资源：")]),a._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/Amyas/picgo-bed/master/amyas.github.io/72022-04-15-15-20-07.png",alt:"72022-04-15-15-20-07",width:"",height:""}}),a._v(" "),s("h2",{attrs:{id:"_0、缓存实际阐述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0、缓存实际阐述"}},[a._v("#")]),a._v(" 0、缓存实际阐述")]),a._v(" "),s("p",[a._v("今天着重介绍一下浏览器缓存机制，我们知道，浏览器缓存一般是针对静态资源，比如js、css、图片等，所以我们下面的例子围绕一个js文件a.js来阐述，抛开理论式灌输，我们从实际场景出发，一点点完善缓存机制，这种方式，相信大家也回更容易理解。")]),a._v(" "),s("p",[a._v("做一些约定，方便后续比较。")]),a._v(" "),s("ul",[s("li",[a._v("a.js大小为10kb")]),a._v(" "),s("li",[a._v("请求头约定为1kb")]),a._v(" "),s("li",[a._v("响应头约定为1kb")])]),a._v(" "),s("h2",{attrs:{id:"_1、原始模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、原始模型"}},[a._v("#")]),a._v(" 1、原始模型")]),a._v(" "),s("ul",[s("li",[a._v("浏览器请求静态资源a.js。（请求头：1kb）")]),a._v(" "),s("li",[a._v("服务器读取磁盘文件a.js，返给浏览器。（10kb（a.js） + 1kb（响应头） = 11kb）")]),a._v(" "),s("li",[a._v("浏览器再次请求，服务器又重新读取磁盘文件a.js，反给浏览器")]),a._v(" "),s("li",[a._v("如此循环...")])]),a._v(" "),s("p",[a._v("执行一个往返，流量为10(a.js) + 1(请求头) + 1(响应头) = 12kb")]),a._v(" "),s("p",[a._v("访问10次，流量大约为12 * 10 = 120kb")]),a._v(" "),s("p",[a._v("所以，流量与访问次数有关：")]),a._v(" "),s("p",[a._v("L(流量) = N(访问次数) * 12")]),a._v(" "),s("p",[a._v("该方式缺点很明显：")]),a._v(" "),s("ul",[s("li",[a._v("浪费用户流量")]),a._v(" "),s("li",[a._v("浪费服务器资源，服务器要读取磁盘文件，然后发送文件到浏览器")]),a._v(" "),s("li",[a._v("浏览器要等待a.js下载并且执行后才能渲染页面，影响用户体验")])]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),s("p",[a._v("js执行时间相比下载时间要快得多，如果能优化下载时间，用户体验会提升很多")])]),a._v(" "),s("h2",{attrs:{id:"_2、浏览器增加缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、浏览器增加缓存机制"}},[a._v("#")]),a._v(" 2、浏览器增加缓存机制")]),a._v(" "),s("ul",[s("li",[a._v("浏览器第一次请求a.js，缓存a.js到本地磁盘(1 + 10 + 1 = 12kb)")]),a._v(" "),s("li",[a._v("浏览器再次请求a.js，直接走浏览器缓存(200， from cache)，不再向服务器发起请求(0kb)")])]),a._v(" "),s("p",[a._v("第一次访问，流量为1 + 10 + 1 = 12kb，第二次访问流量为0，第1000次访问，流量依然为0")]),a._v(" "),s("p",[a._v("所以流量与访问次数有关：")]),a._v(" "),s("p",[a._v("L(流量) = 12kb")]),a._v(" "),s("p",[a._v("优点：")]),a._v(" "),s("ul",[s("li",[a._v("大大减少贷款")]),a._v(" "),s("li",[a._v("由于减少了a.js下载时间，响应的提高了用户体验")])]),a._v(" "),s("p",[a._v("缺点：服务器上a.js更新时，浏览器感知不到，拿不到最近的js资源")]),a._v(" "),s("h2",{attrs:{id:"_3、服务器和浏览器约定资源过期时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、服务器和浏览器约定资源过期时间"}},[a._v("#")]),a._v(" 3、服务器和浏览器约定资源过期时间")]),a._v(" "),s("p",[a._v("服务器和浏览器约定文件过期时间，用"),s("code",[a._v("Expires")]),a._v("字段来控制，时间是GMT格式的标准时间，如Fri, 01 Jan 1990 00:00:00 GMT。")]),a._v(" "),s("ul",[s("li",[a._v("浏览器第一次请求一个静态资源a.js(1kb)")]),a._v(" "),s("li",[a._v("服务器把a.js和a.js的缓存过期时间(Expires: Mon, 26 Sep 2018 05:00:00 GMT)发送给浏览器(10 + 1 = 11kb)")])]),a._v(" "),s("p",[a._v("服务器告诉浏览器：你把我发给你的a.js文件缓存到你那里，在2018年9月26日5点之前不要在发请求烦我，直接使用你自己缓存的a.js就行了。")]),a._v(" "),s("ul",[s("li",[a._v("浏览器接收到a.js，同时记住了过期时间")]),a._v(" "),s("li",[a._v("在2018年9月26日5点之前，浏览器再次请求a.js，便不再请求服务器，直接使用上一次缓存的a.js文件(0kb)")]),a._v(" "),s("li",[a._v("在2018年9月26日5点01分，浏览器请求a.js，发现a.js缓存时间过了，于是不再使用本地缓存，而是请求服务器，服务器又重新读取磁盘文件a.js，返给浏览器，同时告诉浏览器一个新的过期时间(1+10+1=12kb)")]),a._v(" "),s("li",[a._v("如此往复...")])]),a._v(" "),s("p",[a._v("该种方式较之前的方式有了很大的改善：")]),a._v(" "),s("ul",[s("li",[a._v("在过期时间以内，为用户省了很多流量")]),a._v(" "),s("li",[a._v("减少了服务器重复读取磁盘文件的压力")]),a._v(" "),s("li",[a._v("缓存过期后，能够得到最新的a.js文件")])]),a._v(" "),s("p",[a._v("缺点还是有：")]),a._v(" "),s("ul",[s("li",[a._v("缓存过期以后，服务器不管a.js有没有变化，都会再次读取a.js文件，并返给浏览器")])]),a._v(" "),s("h2",{attrs:{id:"_4、服务器告诉浏览器资源上次修改时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、服务器告诉浏览器资源上次修改时间"}},[a._v("#")]),a._v(" 4、服务器告诉浏览器资源上次修改时间")]),a._v(" "),s("p",[a._v("为了解决上个方案的问题，服务器和浏览器经过磋商，制定了一种方案，服务器每次返回a.js的时候，还是要告诉浏览器a.js在服务器上最近修改时间"),s("code",[a._v("Last-Modified")]),a._v("(GMT标准格式)")]),a._v(" "),s("ul",[s("li",[a._v("浏览器访问a.js文件(1kb)")]),a._v(" "),s("li",[a._v("服务器返回a.js的时候，告诉浏览器a.js文件(10 + 1 = 11kb)在服务器的上次修改时间"),s("code",[a._v("Last-Modified")]),a._v("(GMT标准格式)以及缓存过期时间"),s("code",[a._v("Expires")]),a._v("(GMT标准格式)")]),a._v(" "),s("li",[a._v("当a.js文件过期时，浏览器带上"),s("code",[a._v("If-Modified-Since")]),a._v("(等于上一次请求的Last-Modified)请求服务器(1kb)")]),a._v(" "),s("li",[a._v("服务器比较请求头里的"),s("code",[a._v("Last-Modified")]),a._v("时间和服务器上a.js的上次修改时间：\n"),s("ul",[s("li",[a._v("如果一致，则告诉浏览器：你可以继续使用本地缓存(304)，此时，服务器不再返回a.js文件(1kb)")]),a._v(" "),s("li",[a._v("如果不一致，服务器读取 磁盘上的a.js文件放给浏览器，同时告诉浏览器a.js的最近的修改时间"),s("code",[a._v("Last-Modified")]),a._v("以及过期时间"),s("code",[a._v("Expires")]),a._v("(1+10=11kb)")]),a._v(" "),s("li",[a._v("如此往复")])])])]),a._v(" "),s("p",[a._v("此种方案比上一个方案有了更进一步的优化：")]),a._v(" "),s("ul",[s("li",[a._v("缓存过期后，服务器检测如果文件没变化，不再把a.js，不再把a.js发给浏览器，省去了10kb的流量")]),a._v(" "),s("li",[a._v("缓存过期后，服务器检测文件有变化，则把最新的a.js发给浏览器，浏览器能够得到最新的a.js")])]),a._v(" "),s("p",[a._v("缺点：")]),a._v(" "),s("ul",[s("li",[a._v("Expires过期控制不稳定，因为浏览器可以随意修改时间，导致缓存使用不准")]),a._v(" "),s("li",[a._v("Last-Modified过期时间只能精确到秒")])]),a._v(" "),s("p",[a._v("精确到秒存在两个问题：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("如果a.js在一秒时间内经常变动，同时服务器给a.js设置无缓存，那浏览器每次访问a.js，都会请求服务器，此时服务器比较发给浏览器的上次修改时间和a.js最近修改时间，发现都是在同一时间(因为精确到秒)，因此返回给浏览器继续使用本地缓存的消息(304)，但事实上服务器上的a.js已经改动了好多次了，所以这种情况，浏览器拿不到最新的a.js文件。")])]),a._v(" "),s("li",[s("p",[a._v("如果在服务器上a.js被修改了，但其实际内容根本没发生变化，会因为Last-Modified时间匹配不上而重新返回a.js给浏览器")])])]),a._v(" "),s("h2",{attrs:{id:"_5、继续改进-增加相对时间的控制-引入cache-contorl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、继续改进-增加相对时间的控制-引入cache-contorl"}},[a._v("#")]),a._v(" 5、继续改进，增加相对时间的控制，引入Cache-Contorl")]),a._v(" "),s("p",[a._v("为了兼容已经实现了上述方案的浏览器，同时加入新的缓存方案，服务器除了告诉浏览器Expires，同时告诉浏览器一个相对时间Cache-Control: max-age=10秒。意思是在10秒以内，使用缓存到浏览器的a.js资源。")]),a._v(" "),s("p",[a._v("浏览器先检查Cache-Control，如果有，则以Cache-Control为准，忽略Expires，如果没有Cache-Control，则以Expires为准。")]),a._v(" "),s("h2",{attrs:{id:"_6、继续改进-增加文件内容对比-引入etag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、继续改进-增加文件内容对比-引入etag"}},[a._v("#")]),a._v(" 6、继续改进，增加文件内容对比，引入Etag")]),a._v(" "),s("p",[a._v("为了解决文件修改之间只能精确到秒带来的问题，我们给服务器引入Etag响应头，a.js内容变了，Etag才变，内容不变，Etag不变，可以理解为Etag是文件内容的唯一ID。同时引入对应的请求头If-None-Match，每次浏览器请求服务器的时候，都带上If-None-Match字段，该字段的值就是上次请求a.js时，服务器返给浏览器的Etag。")]),a._v(" "),s("ul",[s("li",[a._v("浏览器请求a.js")]),a._v(" "),s("li",[a._v("服务器返回a.js，同时告诉浏览器过期绝对时间(Expires)以及相对时间(Cache-Control: max-age=10)，以及a.js上次修改时间Last-Modified，以及a.js的Etag。")]),a._v(" "),s("li",[a._v("10秒内浏览器再次请求a.js，不在请求服务器，直接使用本地缓存。")]),a._v(" "),s("li",[a._v("11秒时，浏览器再次请求a.js，请求服务器，带上上次修改时间If-Modefied-Since和上次的Etag值If-None-Match。")]),a._v(" "),s("li",[a._v("服务器收到浏览器的If-Modified-Since和Etag，发现有If-None-Match，则比较If-None-Match和a.js的Etag值，忽略If-Modified-Since的比较。")]),a._v(" "),s("li",[a._v("a.js文件内容没变化，则Etag和If-None-Match一致，服务器告诉浏览器继续使用本地缓存(304)")]),a._v(" "),s("li",[a._v("如此往复。")])]),a._v(" "),s("h2",{attrs:{id:"_7、结束了吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、结束了吗"}},[a._v("#")]),a._v(" 7、结束了吗？")]),a._v(" "),s("p",[a._v("到此就结束了吗？是的，HTTP缓存机制就是如此了，但是仍然存在一个问题：")]),a._v(" "),s("p",[a._v("浏览器无法主动得知服务器上的a.js资源变化了。")]),a._v(" "),s("p",[a._v("不管用Expires还是Cache-Control，他们都只能够控制缓存是否过期，但是在缓存过期之前，浏览器是无法得知服务器上的资源是否变化的。只有当缓存过期后，浏览器才会发请求询问服务器。")]),a._v(" "),s("h2",{attrs:{id:"_8、最终方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8、最终方案"}},[a._v("#")]),a._v(" 8、最终方案")]),a._v(" "),s("p",[a._v("大家可以想象我们使用a.js的场景，我们一般都是输入网址，访问一个html文件，html文件中会引入js、css、图片等资源。")]),a._v(" "),s("p",[a._v("所以呢，我们在html上做一些手脚。")]),a._v(" "),s("p",[a._v("我们不让html文件缓存，每次访问html都去请求服务器。所以浏览器每次都能拿到最新的html资源。")]),a._v(" "),s("p",[a._v("a.js内容更新的时候，我们修改一下html中a.js的版本号。")]),a._v(" "),s("ul",[s("li",[a._v("第一次访问html")])]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("script src"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"a.js?version=1"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),s("ul",[s("li",[a._v("浏览器下载verison=1版本的a.js文件。")]),a._v(" "),s("li",[a._v("浏览器再次访问html，发现还是verison=1的a.js文件，则使用本地缓存。")]),a._v(" "),s("li",[a._v("某一天a.js变了，我们的html文件也相应变化如下：")])]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("script src"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"a.js?version=2"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),s("ul",[s("li",[a._v("浏览器再次访问html，发现version=2的a.js资源没有缓存，则请求服务器，服务器返回最新的。")]),a._v(" "),s("li",[a._v("如此往复")])]),a._v(" "),s("p",[a._v("所以，通过设置html不缓存，html引用资源内容变化则改变资源路径的方式，九解决了无法及时得知资源更新的问题。")]),a._v(" "),s("p",[a._v("当然除了以版本号来区分，也可以以MD5Hash值来区分，如：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("script src"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"a.[hash].js"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("script"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),s("p",[a._v("使用webpack打包的话，借助插件可以很方便的处理。")]),a._v(" "),s("h2",{attrs:{id:"_9、补充"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9、补充"}},[a._v("#")]),a._v(" 9、补充")]),a._v(" "),s("p",[a._v("Cache-Control除了可以设置max-age相对过期时间以外，还可以设置成如下几种值：")]),a._v(" "),s("ul",[s("li",[a._v("public，资源允许被中间服务器缓存。")])]),a._v(" "),s("p",[s("strong",[a._v("浏览器请求服务器时，如果缓存时间没到，中间服务器直接返回给浏览器内容，而不必请求源服务器")])]),a._v(" "),s("ul",[s("li",[a._v("private，资源不允许被中间代理服务器缓存。")])]),a._v(" "),s("p",[s("strong",[a._v("浏览器请求服务器时，中间服务器都要把浏览器的请求透传给服务器")])]),a._v(" "),s("ul",[s("li",[a._v("no-cache，浏览器不做缓存检查")])]),a._v(" "),s("p",[s("strong",[a._v("每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存(304)")])]),a._v(" "),s("ul",[s("li",[a._v("no-store，浏览器和中间服代理服务器都不能缓存资源")])]),a._v(" "),s("p",[s("strong",[a._v("每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源")])]),a._v(" "),s("ul",[s("li",[a._v("must-revalidate，可以缓存，但是使用之前必须先向源服务器确认。")]),a._v(" "),s("li",[a._v("proxy-revalidate，要求缓存服务器对缓存资源向源服务器进行确认。")]),a._v(" "),s("li",[a._v("s-maxage，缓存服务器对资源缓存的最大时间。")])]),a._v(" "),s("p",[a._v("Cache-Control对缓存的控制粒度更细，包括缓存代理服务器的缓存控制。")])])}),[],!1,null,null,null);s.default=t.exports}}]);