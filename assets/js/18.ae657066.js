(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{289:function(t,a,n){"use strict";n.r(a);var s=n(13),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_7-jcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-jcc"}},[t._v("#")]),t._v(" 7.jcc")]),t._v(" "),a("h2",{attrs:{id:"jmp-指令-修改-eip-的值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmp-指令-修改-eip-的值"}},[t._v("#")]),t._v(" JMP 指令：修改 EIP 的值")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("MOV EIP,寄存器/立即数   简写为   JMP 寄存器/立即数\n")])])]),a("h2",{attrs:{id:"call-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-指令"}},[t._v("#")]),t._v(" CALL 指令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\tPUSH 地址B\n\n\tMOV EIP,地址A/寄存器\t\t\t简写为：CALL 地址A/寄存器\n")])])]),a("h2",{attrs:{id:"ret-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ret-指令"}},[t._v("#")]),t._v(" RET 指令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\tLEA ESP,[ESP+4]\n\n\tMOV EIP，[ESP-4]\t\t\t简写为：RET\n")])])]),a("h2",{attrs:{id:"cmp-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cmp-指令"}},[t._v("#")]),t._v(" CMP 指令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\t指令格式：CMP  R/M,R/M/IMM\n\n\t该指令是比较两个操作数,实际上,它相当于SUB指令,但是相减的结构并不保存到第一个操作数中。\n\n\t只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置1。\n\n\tMOV EAX,100\n\tMOV ECX,100\n\tCMP EAX,ECX\t\t\t观察Z位\n\n\n\tMOV EAX,100\n\tMOV ECX,200\n\tCMP EAX,ECX\t\t\t观察S位\n\n\n\tCMP AX,WORD PTR DS:[405000]\n\n\tCMP AL,BYTE PTR DS:[405000]\n\n\tCMP EAX,DWORD PTR DS:[405000]\n")])])]),a("h2",{attrs:{id:"test-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-指令"}},[t._v("#")]),t._v(" TEST 指令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\t指令格式：TEST  R/M,R/M/IMM\n\n\t该指令在一定程序上和CMP指令时类似的,两个数值进行与操作,结果不保存,但是会改变相应标志位.\n\n\t与的操作表项如下：\n\n\t1 and 1 = 1\n\n\t1 and 0 = 0\n\n\t0 and 1 = 0\n\n\t0 and 0 = 0\n\n\t常见用法：用这个指令,可以确定某寄存器是否等于0。\n\n\tTEST EAX,EAX\t\t\t观察Z位\n\n\t但是如果EAX的二进制某些位为1的话,那么运算的结果就不为零。\n")])])]),a("h2",{attrs:{id:"jcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jcc"}},[t._v("#")]),t._v(" JCC")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("JE, JZ 结果为零则跳转(相等时跳转) ZF=1")])]),t._v(" "),a("li",[a("p",[t._v("JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0")])]),t._v(" "),a("li",[a("p",[t._v("JS 结果为负则跳转 SF=1")])]),t._v(" "),a("li",[a("p",[t._v("JNS 结果为非负则跳转 SF=0")])]),t._v(" "),a("li",[a("p",[t._v("JP, JPE 结果中 1 的个数为偶数则跳转 PF=1")])]),t._v(" "),a("li",[a("p",[t._v("JNP, JPO 结果中 1 的个数为偶数则跳转 PF=0")])]),t._v(" "),a("li",[a("p",[t._v("JO 结果溢出了则跳转 OF=1")])]),t._v(" "),a("li",[a("p",[t._v("JNO 结果没有溢出则跳转 OF=0")])]),t._v(" "),a("li",[a("p",[t._v("JB, JNAE 小于则跳转 (无符号数) CF=1")])]),t._v(" "),a("li",[a("p",[t._v("JNB, JAE 大于等于则跳转 (无符号数) CF=0")])]),t._v(" "),a("li",[a("p",[t._v("JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1")])]),t._v(" "),a("li",[a("p",[t._v("JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0")])]),t._v(" "),a("li",[a("p",[t._v("JL, JNGE 小于则跳转 (有符号数) SF≠ OF")])]),t._v(" "),a("li",[a("p",[t._v("JNL, JGE 大于等于则跳转 (有符号数) SF=OF")])]),t._v(" "),a("li",[a("p",[t._v("JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF")])]),t._v(" "),a("li",[a("p",[t._v("JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF")])])]),t._v(" "),a("p",[t._v("有符号无符号的区别：")]),t._v(" "),a("p",[t._v("CMP AL,CL\nJG 0x12345678\nJA 0x12345678")])])}),[],!1,null,null,null);a.default=v.exports}}]);